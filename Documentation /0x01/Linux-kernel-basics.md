## **Основы ядра Linux**  

### **1. Что такое ядро Linux? Основные функции**  

**Ядро Linux** — это центральная часть операционной системы, которая управляет ресурсами компьютера, обеспечивает взаимодействие между аппаратурой и программами.  

**Основные функции:**  
1. **Управление процессами** — создание, планирование, синхронизация.  
2. **Управление памятью** — виртуальная память, кэширование, swap.  
3. **Файловые системы** — работа с дисками, сетевые ФС (NFS, ext4).  
4. **Управление устройствами** — драйверы, ввод-вывод.  
5. **Сетевой стек** — обработка TCP/IP, фильтрация пакетов.  
6. **Безопасность** — права доступа, SELinux, capabilities.  

**Пример из исходников:**  
Структура `task_struct` (описывает процесс в ядре):  
```c
// include/linux/sched.h
struct task_struct {
    volatile long state;            // состояние процесса (R, S, D, Z)
    struct mm_struct *mm;           // управление памятью
    pid_t pid;                      // идентификатор процесса
    struct list_head tasks;         // список процессов
    // ... сотни других полей ...
};
```

---

### **2. Монолитное ядро vs Микроядро. Почему Linux — гибридное?**  

| **Критерий**       | **Монолитное ядро**               | **Микроядро**                     | **Linux (гибрид)**                |
|--------------------|-----------------------------------|-----------------------------------|-----------------------------------|
| **Архитектура**    | Все компоненты в одном адресном пространстве | Только базовые функции в ядре, остальное в user-space | Основные части в ядре, но модули могут загружаться динамически |
| **Производительность** | Высокая (меньше переключений) | Низкая (много IPC)               | Высокая (оптимизированные механизмы) |
| **Надёжность**     | Ошибка может уронить всю ОС       | Отказ компонента не затрагивает ядро | Критические части защищены |
| **Примеры**        | Linux, FreeBSD                    | QNX, MINIX                       | Linux с модулями (`*.ko`) |

**Почему Linux гибридное?**  
- Основные компоненты (планировщик, сетевой стек) работают в kernel-space.  
- Драйверы и некоторые подсистемы могут быть вынесены в модули (`*.ko`), которые загружаются динамически.  

**Пример модуля ядра:**  
```c
// hello_kernel.c
#include <linux/init.h>
#include <linux/module.h>

MODULE_LICENSE("GPL");

static int __init hello_init(void) {
    printk(KERN_INFO "Hello, Kernel!\n");
    return 0;
}

static void __exit hello_exit(void) {
    printk(KERN_INFO "Goodbye, Kernel!\n");
}

module_init(hello_init);
module_exit(hello_exit);
```
Сборка:  
```bash
obj-m += hello_kernel.o
make -C /lib/modules/$(uname -r)/build M=$(pwd) modules
```

---

### **3. Загрузка ядра: от BIOS/UEFI до `init`**  

**Схема загрузки:**  
```
BIOS/UEFI → Загрузчик (GRUB) → Ядро (vmlinuz) → Initramfs → Монтирование корневой ФС → Запуск /sbin/init (systemd)
```

**Этапы:**  
1. **BIOS/UEFI** — ищет загрузочное устройство, загружает **GRUB**.  
2. **GRUB** — загружает ядро (`vmlinuz`) и `initramfs` (временная ФС).  
3. **Ядро** — инициализирует CPU, память, драйверы, монтирует корневую ФС.  
4. **Init** — запускается первая программа (`systemd` или `init`).  

**Пример из исходников (инициализация ядра):**  
```c
// init/main.c
void __init start_kernel(void) {
    setup_arch();           // архитектурно-зависимая инициализация
    mm_init();              // управление памятью
    sched_init();           // планировщик
    rest_init();            // запуск init-процесса
}
```

---

### **4. User-space vs Kernel-space**  

**Схема:**  
```
+---------------------+
|   Приложения (bash, gcc)  |  → User-space (Ring 3)
+---------------------+
|       GLIBC         |  → Интерфейс системных вызовов (syscalls)
+---------------------+
|       Ядро          |  → Kernel-space (Ring 0)
+---------------------+
|   Железо (CPU, RAM) |
+---------------------+
```

**Ключевые отличия:**  
| **Критерий**        | **User-space**               | **Kernel-space**              |
|---------------------|-----------------------------|-------------------------------|
| **Уровень привилегий** | Ring 3 (ограниченный)     | Ring 0 (полный доступ)       |
| **Доступ к памяти** | Только своя виртуальная     | Вся физическая память        |
| **Ошибки**          | Убивают процесс             | Убивают всю систему (oops/panic) |
| **Примеры**         | Bash, Python               | Драйверы, файловые системы   |

**Пример системного вызова (`open`):**  
```c
// fs/open.c
SYSCALL_DEFINE3(open, const char __user *, filename, int, flags, umode_t, mode) {
    return do_sys_open(AT_FDCWD, filename, flags, mode);
}
```
При вызове `open()` в user-space происходит переход в kernel-mode через инструкцию `syscall`.  

---
